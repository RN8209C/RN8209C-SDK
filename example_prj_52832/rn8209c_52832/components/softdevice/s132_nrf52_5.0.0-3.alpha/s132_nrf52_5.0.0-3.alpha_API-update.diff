
|-----------------------------------------------------------------------------|
|  Connection-Oriented Channels in LE Credit Based Flow Control Mode          |
|-----------------------------------------------------------------------------|
//| 
//| New L2CAP specific connection configuration ID
//| 
 enum BLE_CONN_CFGS
 {
     BLE_CONN_CFG_GAP = BLE_CONN_CFG_BASE,  /**< BLE GAP specific connection configuration. */
     BLE_CONN_CFG_GATTC,                    /**< BLE GATTC specific connection configuration. */
     BLE_CONN_CFG_GATTS,                    /**< BLE GATTS specific connection configuration. */
     BLE_CONN_CFG_GATT,                     /**< BLE GATT specific connection configuration. */
+    BLE_CONN_CFG_L2CAP,                    /**< BLE L2CAP specific connection configuration. */
 };

//| 
//| New L2CAP connection configuration
//|  
 typedef struct
 {
   uint8_t              conn_cfg_tag;        /**< The application chosen tag it can use with the @ref sd_ble_gap_adv_start() and @ref sd_ble_gap_connect()
                                                  calls to select this configuration when creating a connection.
                                                  Must be different for all connection configurations added and not @ref BLE_CONN_CFG_TAG_DEFAULT. */
   union {
     ble_gap_conn_cfg_t   gap_conn_cfg;      /**< GAP connection configuration, cfg_id is @ref BLE_CONN_CFG_GAP. */
     ble_gattc_conn_cfg_t gattc_conn_cfg;    /**< GATTC connection configuration, cfg_id is @ref BLE_CONN_CFG_GATTC. */
     ble_gatts_conn_cfg_t gatts_conn_cfg;    /**< GATTS connection configuration, cfg_id is @ref BLE_CONN_CFG_GATTS. */
     ble_gatt_conn_cfg_t  gatt_conn_cfg;     /**< GATT connection configuration, cfg_id is @ref BLE_CONN_CFG_GATT. */
+    ble_l2cap_conn_cfg_t l2cap_conn_cfg;    /**< L2CAP connection configuration, cfg_id is @ref BLE_CONN_CFG_L2CAP. */
   } params;                                 /**< Connection configuration union. */
 } ble_conn_cfg_t;
  
//| 
//| New L2CAP originated event
//|  
 typedef struct
 {
   ble_evt_hdr_t header;           /**< Event header. */
   union
   {
     ble_common_evt_t  common_evt; /**< Common Event, evt_id in BLE_EVT_* series. */
     ble_gap_evt_t     gap_evt;    /**< GAP originated event, evt_id in BLE_GAP_EVT_* series. */
     ble_gattc_evt_t   gattc_evt;  /**< GATT client originated event, evt_id in BLE_GATTC_EVT* series. */
     ble_gatts_evt_t   gatts_evt;  /**< GATT server originated event, evt_id in BLE_GATTS_EVT* series. */
+    ble_l2cap_evt_t   l2cap_evt;  /**< L2CAP originated event, evt_id in BLE_L2CAP_EVT* series. */
   } evt;                          /**< Event union. */
 } ble_evt_t;
 
//|
//| API additions related to Connection-Oriented Channels
//|

+/**@addtogroup BLE_L2CAP_TERMINOLOGY Terminology
+ * @{
+ * @details
+ *
+ * L2CAP SDU
+ * - A data unit that the application can send/receive to/from a peer.
+ *
+ * L2CAP PDU
+ * - A data unit that is exchanged between local and remote L2CAP entities.
+ *   It consists of L2CAP protocol control information and payload fields.
+ *   The payload field can contain an L2CAP SDU or a part of an L2CAP SDU.
+ *
+ * L2CAP MTU
+ * - The maximum length of an L2CAP SDU.
+ *
+ * L2CAP MPS
+ * - The maximum length of an L2CAP PDU payload field.
+ *
+ * Credits
+ * - A value indicating the number of L2CAP PDUs that the receiver of the credit can send to the peer.
+ * @} */
+
+/**@addtogroup BLE_L2CAP_ENUMERATIONS Enumerations
+ * @{ */
+
+/**@brief L2CAP API SVC numbers. */
+enum BLE_L2CAP_SVCS
+{
+  SD_BLE_L2CAP_CH_SETUP = BLE_L2CAP_SVC_BASE,           /**< Set up an L2CAP channel. */
+  SD_BLE_L2CAP_CH_RELEASE,                              /**< Release an L2CAP channel. */
+  SD_BLE_L2CAP_CH_RX,                                   /**< Receive an SDU on an L2CAP channel. */
+  SD_BLE_L2CAP_CH_TX,                                   /**< Transmit an SDU on an L2CAP channel. */
+  SD_BLE_L2CAP_CH_FLOW_CONTROL,                         /**< Advanced SDU reception flow control. */
+};
+
+/**@brief L2CAP Event IDs. */
+enum BLE_L2CAP_EVTS
+{
+  BLE_L2CAP_EVT_CH_SETUP_REQUEST = BLE_L2CAP_EVT_BASE,  /**< L2CAP Channel Setup Request event.
+                                                          \n See @ref ble_l2cap_evt_ch_setup_request_t. */
+  BLE_L2CAP_EVT_CH_SETUP_REFUSED,                       /**< L2CAP Channel Setup Refused event.
+                                                          \n See @ref ble_l2cap_evt_ch_setup_refused_t. */
+  BLE_L2CAP_EVT_CH_SETUP,                               /**< L2CAP Channel Setup Completed event.
+                                                          \n See @ref ble_l2cap_evt_ch_setup_t. */
+  BLE_L2CAP_EVT_CH_RELEASED,                            /**< L2CAP Channel Released event.
+                                                          \n No additional event structure applies. */
+  BLE_L2CAP_EVT_CH_SDU_BUF_RELEASED,                    /**< L2CAP Channel SDU data buffer released event.
+                                                          \n See @ref ble_l2cap_evt_ch_sdu_buf_released_t. */
+  BLE_L2CAP_EVT_CH_CREDIT,                              /**< L2CAP Channel Credit received.
+                                                          \n See @ref ble_l2cap_evt_ch_credit_t. */
+  BLE_L2CAP_EVT_CH_RX,                                  /**< L2CAP Channel SDU received.
+                                                          \n See @ref ble_l2cap_evt_ch_rx_t. */
+  BLE_L2CAP_EVT_CH_TX,                                  /**< L2CAP Channel SDU transmitted.
+                                                          \n See @ref ble_l2cap_evt_ch_tx_t. */
+};
+
+/** @} */
+
 /**@addtogroup BLE_L2CAP_DEFINES Defines
  * @{ */
 
+/**@brief Maximum number of L2CAP channels per connection. */
+#define BLE_L2CAP_CH_COUNT_MAX    (64)
+
+/**@brief Minimum L2CAP MTU, in bytes. */
+#define BLE_L2CAP_MTU_MIN         (23)
+
+/**@brief Minimum L2CAP MPS, in bytes. */
+#define BLE_L2CAP_MPS_MIN         (23)
+
+/**@brief Invalid CID. */
+#define BLE_L2CAP_CID_INVALID     (0x0000)
+
+/**@brief Default number of credits for @ref sd_ble_l2cap_ch_flow_control. */
+#define BLE_L2CAP_CREDITS_DEFAULT (1)
+
+/**@defgroup BLE_L2CAP_CH_SETUP_REFUSED_SRCS L2CAP channel setup refused sources
+ * @{ */
+#define BLE_L2CAP_CH_SETUP_REFUSED_SRC_LOCAL            (0x01)    /**< Local. */
+#define BLE_L2CAP_CH_SETUP_REFUSED_SRC_REMOTE           (0x02)    /**< Remote. */
+ /** @}  */
+
+ /** @defgroup BLE_L2CAP_CH_STATUS_CODES L2CAP channel status codes
+ * @{ */
+#define BLE_L2CAP_CH_STATUS_CODE_SUCCESS                (0x0000)  /**< Success. */
+#define BLE_L2CAP_CH_STATUS_CODE_LE_PSM_NOT_SUPPORTED   (0x0002)  /**< LE_PSM not supported. */
+#define BLE_L2CAP_CH_STATUS_CODE_NO_RESOURCES           (0x0004)  /**< No resources available. */
+#define BLE_L2CAP_CH_STATUS_CODE_INSUFF_AUTHENTICATION  (0x0005)  /**< Insufficient authentication. */
+#define BLE_L2CAP_CH_STATUS_CODE_INSUFF_AUTHORIZATION   (0x0006)  /**< Insufficient authorization. */
+#define BLE_L2CAP_CH_STATUS_CODE_INSUFF_ENC_KEY_SIZE    (0x0007)  /**< Insufficient encryption key size. */
+#define BLE_L2CAP_CH_STATUS_CODE_INSUFF_ENC             (0x0008)  /**< Insufficient encryption. */
+#define BLE_L2CAP_CH_STATUS_CODE_INVALID_SCID           (0x0009)  /**< Invalid Source CID. */
+#define BLE_L2CAP_CH_STATUS_CODE_SCID_ALLOCATED         (0x000A)  /**< Source CID already allocated. */
+#define BLE_L2CAP_CH_STATUS_CODE_UNACCEPTABLE_PARAMS    (0x000B)  /**< Unacceptable parameters. */
+#define BLE_L2CAP_CH_STATUS_CODE_NOT_UNDERSTOOD         (0x8000)  /**< Command Reject received instead of LE Credit Based Connection Response. */
+#define BLE_L2CAP_CH_STATUS_CODE_TIMEOUT                (0xC000)  /**< Operation timed out. */
+/** @} */
+
+/** @} */
+
+/**@addtogroup BLE_L2CAP_STRUCTURES Structures
+ * @{ */
+
+/**
+ * @brief BLE L2CAP connection configuration parameters, set with @ref sd_ble_cfg_set.
+ *
+ * @retval ::NRF_ERROR_INVALID_PARAM  One or more of the following is true:
+ *                                    - rx_mps is smaller than @ref BLE_L2CAP_MPS_MIN.
+ *                                    - tx_mps is smaller than @ref BLE_L2CAP_MPS_MIN.
+ *                                    - ch_count is greater than @ref BLE_L2CAP_CH_COUNT_MAX.
+ */
+typedef struct
+{
+  uint16_t    rx_mps;        /**< The maximum L2CAP PDU payload size, in bytes, that L2CAP shall
+                                  be able to receive on L2CAP channels on connections with this
+                                  configuration. The minimum value is @ref BLE_L2CAP_MPS_MIN. */
+  uint16_t    tx_mps;        /**< The maximum L2CAP PDU payload size, in bytes, that L2CAP shall
+                                  be able to transmit on L2CAP channels on connections with this
+                                  configuration. The minimum value is @ref BLE_L2CAP_MPS_MIN. */
+  uint8_t     rx_queue_size; /**< Number of SDU data buffers that can be queued for reception per
+                                  L2CAP channel. The minimum value is zero. */
+  uint8_t     tx_queue_size; /**< Number of SDU data buffers that can be queued for transmission
+                                  per L2CAP channel. The minimum value is zero. */
+  uint8_t     ch_count;      /**< Number of L2CAP channels the application can create per connection
+                                  with this configuration. The default value is zero, the maximum
+                                  value is @ref BLE_L2CAP_CH_COUNT_MAX.
+                                  @note if this parameter is set to zero, all other parameters in
+                                  @ref ble_l2cap_conn_cfg_t are ignored. */
+} ble_l2cap_conn_cfg_t;
+
+/**@brief L2CAP channel RX parameters. */
+typedef struct
+{
+  uint16_t    rx_mtu;        /**< The maximum L2CAP SDU size, in bytes, that L2CAP shall be able to
+                                  receive on this L2CAP channel.
+                                  - Must be equal to or greater than @ref BLE_L2CAP_MTU_MIN. */
+  uint16_t    rx_mps;        /**< The maximum L2CAP PDU payload size, in bytes, that L2CAP shall be
+                                  able to receive on this L2CAP channel.
+                                  - Must be equal to or greater than @ref BLE_L2CAP_MPS_MIN.
+                                  - Must be equal to or less than @ref ble_l2cap_conn_cfg_t::rx_mps. */
+  ble_data_t  sdu_buf;       /**< SDU data buffer for reception.
+                                  - If @ref ble_data_t::p_data is non-NULL, initial credits are
+                                    issued to the peer.
+                                  - If @ref ble_data_t::p_data is NULL, no initial credits are
+                                    issued to the peer. */
+} ble_l2cap_ch_rx_params_t;
+
+/**@brief L2CAP channel setup parameters. */
+typedef struct
+{
+  ble_l2cap_ch_rx_params_t      rx_params;  /**< L2CAP channel RX parameters. */
+  uint16_t                      le_psm;     /**< LE Protocol/Service Multiplexer. Used when requesting
+                                                 setup of an L2CAP channel, ignored otherwise. */
+  uint16_t                      status;     /**< Status code, see @ref BLE_L2CAP_CH_STATUS_CODES.
+                                                 Used when replying to a setup request of an L2CAP
+                                                 channel, ignored otherwise. */
+} ble_l2cap_ch_setup_params_t;
+
+/**@brief L2CAP channel TX parameters. */
+typedef struct
+{
+  uint16_t    tx_mtu;        /**< The maximum L2CAP SDU size, in bytes, that L2CAP is able to
+                                  transmit on this L2CAP channel. */
+  uint16_t    peer_mps;      /**< The maximum L2CAP PDU payload size, in bytes, that the peer is
+                                  able to receive on this L2CAP channel. */
+  uint16_t    tx_mps;        /**< The maximum L2CAP PDU payload size, in bytes, that L2CAP is able
+                                  to transmit on this L2CAP channel. This is effective tx_mps,
+                                  selected by the SoftDevice as
+                                  MIN( @ref ble_l2cap_ch_tx_params_t::peer_mps, @ref ble_l2cap_conn_cfg_t::tx_mps ) */
+  uint16_t    credits;       /**< Initial credits given by the peer. */
+} ble_l2cap_ch_tx_params_t;
+
+/**@brief L2CAP Channel Setup Request event. */
+typedef struct
+{
+  ble_l2cap_ch_tx_params_t  tx_params;  /**< L2CAP channel TX parameters. */
+  uint16_t                  le_psm;     /**< LE Protocol/Service Multiplexer. */
+} ble_l2cap_evt_ch_setup_request_t;
+
+/**@brief L2CAP Channel Setup Refused event. */
+typedef struct
+{
+  uint8_t  source;           /**< Source, see @ref BLE_L2CAP_CH_SETUP_REFUSED_SRCS */
+  uint16_t status;           /**< Status code, see @ref BLE_L2CAP_CH_STATUS_CODES */
+} ble_l2cap_evt_ch_setup_refused_t;
+
+/**@brief L2CAP Channel Setup Completed event. */
+typedef struct
+{
+  ble_l2cap_ch_tx_params_t tx_params;  /**< L2CAP channel TX parameters. */
+} ble_l2cap_evt_ch_setup_t;
+
+/**@brief L2CAP Channel SDU Data Duffer Released event. */
+typedef struct
+{
+  ble_data_t  sdu_buf;       /**< Returned reception or transmission SDU data buffer. The SoftDevice
+                                  returns SDU data buffers supplied by the application, which have
+                                  not yet been returned previously via a @ref BLE_L2CAP_EVT_CH_RX or
+                                  @ref BLE_L2CAP_EVT_CH_TX event. */
+} ble_l2cap_evt_ch_sdu_buf_released_t;
+
+/**@brief L2CAP Channel Credit received event. */
+typedef struct
+{
+  uint16_t  credits;         /**< Additional credits given by the peer. */
+} ble_l2cap_evt_ch_credit_t;
+
+/**@brief L2CAP Channel received SDU event. */
+typedef struct
+{
+  uint16_t    sdu_len;       /**< Total SDU length, in bytes. */
+  ble_data_t  sdu_buf;       /**< SDU data buffer.
+                                  @note If there is not enough space in the buffer
+                                        (sdu_buf.len < sdu_len) then the rest of the SDU will be
+                                        silently discarded by the SoftDevice. */
+} ble_l2cap_evt_ch_rx_t;
+
+/**@brief L2CAP Channel transmitted SDU event. */
+typedef struct
+{
+  ble_data_t  sdu_buf;       /**< SDU data buffer. */
+} ble_l2cap_evt_ch_tx_t;
+
+/**@brief L2CAP event structure. */
+typedef struct
+{
+  uint16_t conn_handle;                                     /**< Connection Handle on which the event occured. */
+  uint16_t local_cid;                                       /**< Local Channel ID of the L2CAP channel, or
+                                                                 @ref BLE_L2CAP_CID_INVALID if not present. */
+  union
+  {
+    ble_l2cap_evt_ch_setup_request_t    ch_setup_request;   /**< L2CAP Channel Setup Request Event Parameters. */
+    ble_l2cap_evt_ch_setup_refused_t    ch_setup_refused;   /**< L2CAP Channel Setup Refused Event Parameters. */
+    ble_l2cap_evt_ch_setup_t            ch_setup;           /**< L2CAP Channel Setup Completed Event Parameters. */
+    ble_l2cap_evt_ch_sdu_buf_released_t ch_sdu_buf_released;/**< L2CAP Channel SDU Data Buffer Released Event Parameters. */
+    ble_l2cap_evt_ch_credit_t           credit;             /**< L2CAP Channel Credit Received Event Parameters. */
+    ble_l2cap_evt_ch_rx_t               rx;                 /**< L2CAP Channel SDU Received Event Parameters. */
+    ble_l2cap_evt_ch_tx_t               tx;                 /**< L2CAP Channel SDU Transmitted Event Parameters. */
+  } params;                                                 /**< Event Parameters. */
+} ble_l2cap_evt_t;
+
+/** @} */
+
+/**@addtogroup BLE_L2CAP_FUNCTIONS Functions
+ * @{ */
+
+/**@brief Set up an L2CAP channel.
+ *
+ * @details This function is used to:
+ *          - Request setup of an L2CAP channel: sends an LE Credit Based Connection Request packet to a peer.
+ *          - Reply to a setup request of an L2CAP channel (if called in response to a
+ *            @ref BLE_L2CAP_EVT_CH_SETUP_REQUEST event): sends an LE Credit Based Connection
+ *            Response packet to a peer.
+ *
+ * @note    A call to this function will require the application to keep the SDU data buffer alive
+ *          until the SDU data buffer is returned in @ref BLE_L2CAP_EVT_CH_RX or
+ *          @ref BLE_L2CAP_EVT_CH_SDU_BUF_RELEASED event.
+ *
+ * @events
+ * @event{@ref BLE_L2CAP_EVT_CH_SETUP, Setup successful.}
+ * @event{@ref BLE_L2CAP_EVT_CH_SETUP_REFUSED, Setup failed.}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_L2CAP_CH_SETUP_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle   Connection Handle.
+ * @param[in] local_cid     Local Channel ID of the L2CAP channel.
+ *                          - Must be @ref BLE_L2CAP_CID_INVALID when requesting setup of an L2CAP
+ *                            channel. local_cid for this channel is then provided in the
+ *                            @ref BLE_L2CAP_EVT_CH_SETUP event.
+ *                          - Must be set to the local_cid provided in the @ref BLE_L2CAP_EVT_CH_SETUP_REQUEST
+ *                            event when replying to a setup request of an L2CAP channel.
+ * @param[in] p_params      L2CAP channel parameters.
+ *
+ * @retval ::NRF_SUCCESS                    Successfully queued request or response for transmission.
+ * @retval ::NRF_ERROR_BUSY                 The stack is busy, process pending events and retry.
+ * @retval ::NRF_ERROR_INVALID_ADDR         Invalid pointer supplied.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE  Invalid Connection Handle.
+ * @retval ::NRF_ERROR_INVALID_PARAM        Invalid parameter(s) supplied.
+ * @retval ::NRF_ERROR_INVALID_LENGTH       Supplied higher rx_mps than has been configured on this link.
+ * @retval ::NRF_ERROR_INVALID_STATE        Invalid State to perform operation (Setup is in progress
+ *                                          for an L2CAP channel).
+ * @retval ::NRF_ERROR_NOT_FOUND            CID not found.
+ * @retval ::NRF_ERROR_RESOURCES            The limit has been reached for available L2CAP channels,
+ *                                          see @ref ble_l2cap_conn_cfg_t::ch_count.
+ */
+SVCALL(SD_BLE_L2CAP_CH_SETUP, uint32_t, sd_ble_l2cap_ch_setup(uint16_t conn_handle, uint16_t local_cid, ble_l2cap_ch_setup_params_t const *p_params));
+
+/**@brief Release an L2CAP channel.
+ *
+ * @details This sends a Disconnection Request packet to a peer.
+ *
+ * @events
+ * @event{@ref BLE_L2CAP_EVT_CH_RELEASED, Release complete.}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_L2CAP_CH_RELEASE_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle   Connection Handle.
+ * @param[in] local_cid     Local Channel ID of the L2CAP channel.
+ *
+ * @retval ::NRF_SUCCESS                    Successfully queued request for transmission.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE  Invalid Connection Handle.
+ * @retval ::NRF_ERROR_INVALID_STATE        Invalid State to perform operation (Setup or release is
+ *                                          in progress for the L2CAP channel).
+ * @retval ::NRF_ERROR_NOT_FOUND            CID not found.
+ */
+SVCALL(SD_BLE_L2CAP_CH_RELEASE, uint32_t, sd_ble_l2cap_ch_release(uint16_t conn_handle, uint16_t local_cid));
+
+/**@brief Receive an SDU on an L2CAP channel.
+ *
+ * @details This may issue additional credits to the peer using an LE Flow Control Credit packet.
+ *
+ * @note    A call to this function will require the application to keep the memory pointed by
+ *          @ref ble_data_t::p_data alive until the SDU data buffer is returned in @ref BLE_L2CAP_EVT_CH_RX
+ *          or @ref BLE_L2CAP_EVT_CH_SDU_BUF_RELEASED event.
+ *
+ * @note    The SoftDevice can queue up to @ref ble_l2cap_conn_cfg_t::rx_queue_size SDU data buffers
+ *          for reception per L2CAP channel.
+ *
+ * @events
+ * @event{@ref BLE_L2CAP_EVT_CH_RX, The SDU is received.}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_L2CAP_CH_RX_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle Connection Handle.
+ * @param[in] local_cid   Local Channel ID of the L2CAP channel.
+ * @param[in] p_sdu_buf   Pointer to the SDU data buffer.
+ *
+ * @retval ::NRF_SUCCESS                    Buffer accepted.
+ * @retval ::NRF_ERROR_INVALID_ADDR         Invalid pointer supplied.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE  Invalid Connection Handle.
+ * @retval ::NRF_ERROR_INVALID_STATE        Invalid State to perform operation (Setup or release is
+ *                                          in progress for an L2CAP channel).
+ * @retval ::NRF_ERROR_NOT_FOUND            CID not found.
+ * @retval ::NRF_ERROR_RESOURCES            Too many SDU data buffers supplied. Wait for a
+ *                                          @ref BLE_L2CAP_EVT_CH_RX event and retry.
+ */
+SVCALL(SD_BLE_L2CAP_CH_RX, uint32_t, sd_ble_l2cap_ch_rx(uint16_t conn_handle, uint16_t local_cid, ble_data_t const *p_sdu_buf));
+
+/**@brief Transmit an SDU on an L2CAP channel.
+ *
+ * @note    A call to this function will require the application to keep the memory pointed by
+ *          @ref ble_data_t::p_data alive until the SDU data buffer is returned in @ref BLE_L2CAP_EVT_CH_TX
+ *          or @ref BLE_L2CAP_EVT_CH_SDU_BUF_RELEASED event.
+ *
+ * @note    The SoftDevice can queue up to @ref ble_l2cap_conn_cfg_t::tx_queue_size SDUs for
+ *          transmission per L2CAP channel.
+ *
+ * @note    The application can keep track of the available credits for transmission by following
+ *          the procedure below:
+ *          - Store initial credits given by the peer in a variable.
+ *            (Initial credits are provided in a @ref BLE_L2CAP_EVT_CH_SETUP event.)
+ *          - Decrement the variable, which stores the currently available credits, by
+ *            ceiling((@ref ble_data_t::len + 2) / tx_mps) when a call to this function returns
+ *            @ref NRF_SUCCESS. (tx_mps is provided in a @ref BLE_L2CAP_EVT_CH_SETUP event.)
+ *          - Increment the variable, which stores the currently available credits, by additional
+ *            credits given by the peer in a @ref BLE_L2CAP_EVT_CH_CREDIT event.
+ *
+ * @events
+ * @event{@ref BLE_L2CAP_EVT_CH_TX, The SDU is transmitted.}
+ * @endevents
+ *
+ * @mscs
+ * @mmsc{@ref BLE_L2CAP_CH_TX_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle Connection Handle.
+ * @param[in] local_cid   Local Channel ID of the L2CAP channel.
+ * @param[in] p_sdu_buf   Pointer to the SDU data buffer.
+ *
+ * @retval ::NRF_SUCCESS                    Successfully queued L2CAP SDU for transmission.
+ * @retval ::NRF_ERROR_INVALID_ADDR         Invalid pointer supplied.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE  Invalid Connection Handle.
+ * @retval ::NRF_ERROR_INVALID_STATE        Invalid State to perform operation (Setup or release is
+ *                                          in progress for the L2CAP channel).
+ * @retval ::NRF_ERROR_NOT_FOUND            CID not found.
+ * @retval ::NRF_ERROR_DATA_SIZE            Invalid SDU length supplied, must not be more than
+ *                                          @ref ble_l2cap_ch_tx_params_t::tx_mtu provided in
+ *                                          @ref BLE_L2CAP_EVT_CH_SETUP event.
+ * @retval ::NRF_ERROR_RESOURCES            Too many SDUs queued for transmission. Wait for a
+ *                                          @ref BLE_L2CAP_EVT_CH_TX event and retry.
+ */
+SVCALL(SD_BLE_L2CAP_CH_TX, uint32_t, sd_ble_l2cap_ch_tx(uint16_t conn_handle, uint16_t local_cid, ble_data_t const *p_sdu_buf));
+
+/**@brief Advanced SDU reception flow control.
+ *
+ * @details Adjust the way the SoftDevice issues credits to the peer.
+ *          This may issue additional credits to the peer using an LE Flow Control Credit packet.
+ *
+ * @mscs
+ * @mmsc{@ref BLE_L2CAP_CH_FLOW_CONTROL_MSC}
+ * @endmscs
+ *
+ * @param[in] conn_handle Connection Handle.
+ * @param[in] local_cid   Local Channel ID of the L2CAP channel.
+ * @param[in] credits     Number of credits that the SoftDevice will make sure the peer has every
+ *                        time it starts using a new reception buffer.
+ *                        - @ref BLE_L2CAP_CREDITS_DEFAULT is the default value the SoftDevice will
+ *                          use if this function is not called.
+ *                        - If set to zero, the SoftDevice will stop issuing credits for new reception
+ *                          buffers the application provides or has provided. SDU reception that is
+ *                          currently ongoing will be allowed to complete.
+ * @param[out] p_credits  NULL or pointer to a uint16_t that will be filled with number of credits
+ *                        that the peer would currently have if all already queued LE Flow Control
+ *                        Credit packets were sent immediately.
+ *
+ * @note Application should take care when setting number of credits higher than default value. In
+ *       this case the application must make sure that the SoftDevice always has reception buffers
+ *       available (see @ref sd_ble_l2cap_ch_rx) for that channel. If the SoftDevice does not have
+ *       such buffers available, packets may be NACKed on the Link Layer and all Bluetooth traffic
+ *       on the connection handle may be stalled until the SoftDevice again has an available
+ *       reception buffer. This applies even if the application has used this call to set the
+ *       credits back to default, or zero.
+ *
+ * @retval ::NRF_SUCCESS                    Flow control parameters accepted.
+ * @retval ::NRF_ERROR_INVALID_ADDR         Invalid pointer supplied.
+ * @retval ::BLE_ERROR_INVALID_CONN_HANDLE  Invalid Connection Handle.
+ * @retval ::NRF_ERROR_INVALID_STATE        Invalid State to perform operation (Setup or release is
+ *                                          in progress for an L2CAP channel).
+ * @retval ::NRF_ERROR_NOT_FOUND            CID not found.
+ */
+SVCALL(SD_BLE_L2CAP_CH_FLOW_CONTROL, uint32_t, sd_ble_l2cap_ch_flow_control(uint16_t conn_handle, uint16_t local_cid, uint16_t credits, uint16_t *p_credits));

//| 
//| Data buffer provided to/from the application
//| 

+/**@brief Data structure. */
+typedef struct
+{
+  uint8_t     *p_data;  /**< Pointer to the data buffer provided to/from the application. */
+  uint16_t     len;     /**< Length of the data buffer, in bytes. */
+} ble_data_t;


|-----------------------------------------------------------------------------|
|  Updates for Bluetooth 5 compliance                                         |
|-----------------------------------------------------------------------------|
//| 
//| Removal of security request timeout source 
//|  
  
 /**@defgroup BLE_GAP_TIMEOUT_SOURCES GAP Timeout sources
  * @{ */
 #define BLE_GAP_TIMEOUT_SRC_ADVERTISING                0x00 /**< Advertising timeout. */
-#define BLE_GAP_TIMEOUT_SRC_SECURITY_REQUEST           0x01 /**< Security request timeout. */
-#define BLE_GAP_TIMEOUT_SRC_SCAN                       0x02 /**< Scanning timeout. */
-#define BLE_GAP_TIMEOUT_SRC_CONN                       0x03 /**< Connection timeout. */
-#define BLE_GAP_TIMEOUT_SRC_AUTH_PAYLOAD               0x04 /**< Authenticated payload timeout. */
+#define BLE_GAP_TIMEOUT_SRC_SCAN                       0x01 /**< Scanning timeout. */
+#define BLE_GAP_TIMEOUT_SRC_CONN                       0x02 /**< Connection timeout. */
+#define BLE_GAP_TIMEOUT_SRC_AUTH_PAYLOAD               0x03 /**< Authenticated payload timeout. */
 /**@} */
 
//| 
//| Lowering of the lower limit for advertising interval for non-connectable advertisement.
//|  
 /**@defgroup BLE_GAP_ADV_INTERVALS GAP Advertising interval max and min
  * @{ */
 #define BLE_GAP_ADV_INTERVAL_MIN        0x0020 /**< Minimum Advertising interval in 625 us units, i.e. 20 ms. */
-#define BLE_GAP_ADV_NONCON_INTERVAL_MIN 0x00A0 /**< Minimum Advertising interval in 625 us units for non connectable mode, i.e. 100 ms. */
 #define BLE_GAP_ADV_INTERVAL_MAX        0x4000 /**< Maximum Advertising interval in 625 us units, i.e. 10.24 s. */
  /**@}  */

|-----------------------------------------------------------------------------|
|  Master boot record                                                         |
|-----------------------------------------------------------------------------|

//| 
//| New API for forwarding all interrupts to a specific address
//|  
/**@brief Possible values for ::sd_mbr_command_t.command */
 enum NRF_MBR_COMMANDS
 {
   SD_MBR_COMMAND_COPY_BL,                 /**< Copy a new BootLoader. @see sd_mbr_command_copy_bl_t*/
   SD_MBR_COMMAND_COPY_SD,                 /**< Copy a new SoftDevice. @see ::sd_mbr_command_copy_sd_t*/
   SD_MBR_COMMAND_INIT_SD,                 /**< Initialize forwarding interrupts to SD, and run reset function in SD*/
   SD_MBR_COMMAND_COMPARE,                 /**< This command works like memcmp. @see ::sd_mbr_command_compare_t*/
   SD_MBR_COMMAND_VECTOR_TABLE_BASE_SET,   /**< Change the address the MBR starts after a reset @see ::sd_mbr_command_vector_table_base_set_t*/
+  SD_MBR_COMMAND_RESERVED,
+  SD_MBR_COMMAND_IRQ_FORWARD_ADDRESS_SET, /**< Start forwarding all interrupts to this address @see ::sd_mbr_command_irq_forward_address_set_t*/
 };

+/**@brief Sets the base address of the interrupt vector table for interrupts forwarded from the MBR
+ * Unlike sd_mbr_command_vector_table_base_set_t, this function does not reset, and it does not
+ * change where the MBR starts after reset.
+ *
+ * @retval ::NRF_SUCCESS
+ */
+typedef struct
+{
+  uint32_t address; /**< The base address of the interrupt vector table for forwarded interrupts.*/
+} sd_mbr_command_irq_forward_address_set_t;
 
 typedef struct
 {
   uint32_t command;  /**< type of command to be issued see @ref NRF_MBR_COMMANDS. */
   union
   {
     sd_mbr_command_copy_sd_t copy_sd;  /**< Parameters for copy SoftDevice.*/
     sd_mbr_command_compare_t compare;  /**< Parameters for verify.*/
     sd_mbr_command_copy_bl_t copy_bl;  /**< Parameters for copy BootLoader. Requires parameter page. */
     sd_mbr_command_vector_table_base_set_t base_set; /**< Parameters for vector table base set. Requires parameter page.*/
+    sd_mbr_command_irq_forward_address_set_t irq_forward_address_set; /**< Parameters for irq forward address set*/
   } params;
 } sd_mbr_command_t;
 
 
|-----------------------------------------------------------------------------|
|  Misc                                                                       |
|-----------------------------------------------------------------------------|

//| 
//| Added defines for Authenticated payload timeout 
//|  
+/**@defgroup BLE_GAP_AUTH_PAYLOAD_TIMEOUT Authenticated payload timeout defines.
+  * @{ */
+#define BLE_GAP_AUTH_PAYLOAD_TIMEOUT_MAX (48000) /**< Maximum authenticated payload timeout in 10 ms units, i.e. 8 minutes. */
+#define BLE_GAP_AUTH_PAYLOAD_TIMEOUT_MIN (1)     /**< Minimum authenticated payload timeout in 10 ms units, i.e. 10 ms. */
+/**@} */
 
 /**@brief Authenticated payload timeout option.
  *
- *        This can be used with @ref sd_ble_opt_set to change the Authenticated payload timeout to a value other than the default of 8 minutes.
+ *        This can be used with @ref sd_ble_opt_set to change the Authenticated payload timeout to a value other
+ *        than the default of @ref BLE_GAP_AUTH_PAYLOAD_TIMEOUT_MAX.
  *
  * @note  The authenticated payload timeout event ::BLE_GAP_TIMEOUT_SRC_AUTH_PAYLOAD will be generated
  *        if auth_payload_timeout time has elapsed without receiving a packet with a valid MIC on an encrypted
  *        link.
  *
  * @note  The LE ping procedure will be initiated before the timer expires to give the peer a chance
  *        to reset the timer. In addition the stack will try to prioritize running of LE ping over other
  *        activities to increase chances of finishing LE ping before timer expires. To avoid side-effects
  *        on other activities, it is recommended to use high timeout values.
  *        Recommended timeout > 2*(connInterval * (6 + connSlaveLatency)).
  *
  * @retval ::NRF_SUCCESS Set successfully.
  * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied. auth_payload_timeout was outside of allowed range.
  * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle parameter.
  */
 typedef struct
 {
   uint16_t   conn_handle;                       /**< Connection Handle */
-  uint16_t   auth_payload_timeout;              /**< Requested timeout in 10 ms unit. Maximum is 48 000 (=480 000 ms =8 min). Minimum is 1 (=10 ms). */
+  uint16_t   auth_payload_timeout;              /**< Requested timeout in 10 ms unit, see @ref BLE_GAP_AUTH_PAYLOAD_TIMEOUT. */
 } ble_gap_opt_auth_payload_timeout_t;

//| 
//| APIs not returning NRF_ERROR_BUSY anymore.
//|  
 /**@brief Start advertising (GAP Discoverable, Connectable modes, Broadcast Procedure).
  *
  * @note Only one advertiser may be active at any time.
  *
  * @param[in] p_adv_params Pointer to advertising parameters structure.
  * @param[in] conn_cfg_tag Tag identifying a configuration set by @ref sd_ble_cfg_set or @ref
- *                         BLE_CONN_CFG_TAG_DEFAULT to use the default connection configuration.
+ *                         BLE_CONN_CFG_TAG_DEFAULT to use the default connection configuration. If
+ *                         @ref ble_gap_adv_params_t::type is @ref BLE_GAP_ADV_TYPE_ADV_NONCONN_IND,
+ *                         this is ignored.
  *
  * @retval ::NRF_SUCCESS The BLE stack has started advertising.
  * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
  * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
  * @retval ::NRF_ERROR_CONN_COUNT The limit of available connections has been reached; connectable advertiser cannot be started.
  * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, check the accepted ranges and limits.
  * @retval ::BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid Bluetooth address supplied.
  * @retval ::BLE_ERROR_GAP_DISCOVERABLE_WITH_WHITELIST Discoverable mode and whitelist incompatible.
- * @retval ::NRF_ERROR_BUSY The stack is busy, process pending events and retry.
  * @retval ::NRF_ERROR_RESOURCES Not enough BLE role slots available.
  *                               Stop one or more currently active roles (Central, Peripheral or Observer) and try again
  */
 SVCALL(SD_BLE_GAP_ADV_START, uint32_t, sd_ble_gap_adv_start(ble_gap_adv_params_t const *p_adv_params, uint8_t conn_cfg_tag));

 
 /**@brief Initiate the GAP Authentication procedure.
  *
  * @details In the central role, this function will send an SMP Pairing Request (or an SMP Pairing Failed if rejected),
  *          otherwise in the peripheral role, an SMP Security Request will be sent.
  *
  * @param[in] conn_handle Connection handle.
  * @param[in] p_sec_params Pointer to the @ref ble_gap_sec_params_t structure with the security parameters to be used during the pairing or bonding procedure.
  *                         In the peripheral role, only the bond, mitm, lesc and keypress fields of this structure are used.
  *                         In the central role, this pointer may be NULL to reject a Security Request.
  *
  * @retval ::NRF_SUCCESS Successfully initiated authentication procedure.
  * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
  * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
  * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
- * @retval ::NRF_ERROR_BUSY The stack is busy, process pending events and retry.
  * @retval ::NRF_ERROR_NO_MEM The maximum number of authentication procedures that can run in parallel for the given role is reached.
  * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
  * @retval ::NRF_ERROR_NOT_SUPPORTED Setting of sign or link fields in @ref ble_gap_sec_kdist_t not supported.
  * @retval ::NRF_ERROR_TIMEOUT A SMP timeout has occurred, and further SMP operations on this link is prohibited.
  */
 SVCALL(SD_BLE_GAP_AUTHENTICATE, uint32_t, sd_ble_gap_authenticate(uint16_t conn_handle, ble_gap_sec_params_t const *p_sec_params));


 /**@brief Start scanning (GAP Discovery procedure, Observer Procedure).
  *
  * @param[in] p_scan_params Pointer to scan parameters structure.
  *
  * @retval ::NRF_SUCCESS Successfully initiated scanning procedure.
  * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
  * @retval ::NRF_ERROR_INVALID_STATE Invalid state to perform operation.
  * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
- * @retval ::NRF_ERROR_BUSY The stack is busy, process pending events and retry.
  * @retval ::NRF_ERROR_RESOURCES Not enough BLE role slots available.
  *                               Stop one or more currently active roles (Central, Peripheral or Broadcaster) and try again
  */
 SVCALL(SD_BLE_GAP_SCAN_START, uint32_t, sd_ble_gap_scan_start(ble_gap_scan_params_t const *p_scan_params));

 /**@brief Create a connection (GAP Link Establishment).
  *
  * @note If a scanning procedure is currently in progress it will be automatically stopped when calling this function.
  *       The scanning procedure will be stopped even if the function returns an error.
  *
  *
  * @param[in] p_peer_addr   Pointer to peer address. If the use_whitelist bit is set in @ref ble_gap_scan_params_t, then this is ignored.
  * @param[in] p_scan_params Pointer to scan parameters structure.
  * @param[in] p_conn_params Pointer to desired connection parameters.
  * @param[in] conn_cfg_tag  Tag identifying a configuration set by @ref sd_ble_cfg_set or @ref
  *                          BLE_CONN_CFG_TAG_DEFAULT to use the default connection configuration.
  *
  * @retval ::NRF_SUCCESS Successfully initiated connection procedure.
  * @retval ::NRF_ERROR_INVALID_ADDR Invalid parameter(s) pointer supplied.
  * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
  *                                   - Invalid parameter(s) in p_scan_params or p_conn_params.
  *                                   - Use of whitelist requested but whitelist has not been set, see @ref sd_ble_gap_whitelist_set.
  *                                   - Peer address was not present in the device identity list, see @ref sd_ble_gap_device_identities_set.
  * @retval ::NRF_ERROR_INVALID_STATE The SoftDevice is in an invalid state to perform this operation. This may be due to an
  *                                   existing locally initiated connect procedure, which must complete before initiating again.
  * @retval ::BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid Peer address.
  * @retval ::NRF_ERROR_CONN_COUNT The limit of available connections has been reached.
- * @retval ::NRF_ERROR_BUSY The stack is busy, process pending events and retry. If another connection is being established
- *                          wait for the corresponding @ref BLE_GAP_EVT_CONNECTED event before calling again.
  * @retval ::NRF_ERROR_RESOURCES Not enough BLE role slots available.
  *                               Stop one or more currently active roles (Central, Peripheral or Broadcaster) and try again
  */
 SVCALL(SD_BLE_GAP_CONNECT, uint32_t, sd_ble_gap_connect(ble_gap_addr_t const *p_peer_addr, ble_gap_scan_params_t const *p_scan_params, ble_gap_conn_params_t const *p_conn_params, uint8_t conn_cfg_tag));

//|
//| New status code for BLE_GAP_EVT_PHY_UPDATE event
//|

 /**@brief Initiate or respond to a PHY Update Procedure
  *
  * @details   This function is used to initiate or respond to a PHY Update Procedure. It will always generate a
  *            @ref BLE_GAP_EVT_PHY_UPDATE event if successfully executed. If @ref ble_gap_phys_t::tx_phys or @ref ble_gap_phys_t::rx_phys
  *            is @ref BLE_GAP_PHY_AUTO, then the stack will select a PHY for the respective direction based on the peer's PHY preferences
  *            and the local stack configuration. If the peer does not support the PHY Update Procedure, then the
  *            resulting @ref BLE_GAP_EVT_PHY_UPDATE event will have a status set to
  *            @ref BLE_HCI_UNSUPPORTED_REMOTE_FEATURE.
  *            If the PHY procedure was rejected by the peer due to a procedure collision, the status will be
  *            @ref BLE_HCI_STATUS_CODE_LMP_ERROR_TRANSACTION_COLLISION or @ref BLE_HCI_DIFFERENT_TRANSACTION_COLLISION.
+ *            If the peer responds to the PHY Update procedure with invalid parameters, the status will be @ref BLE_HCI_STATUS_CODE_INVALID_LMP_PARAMETERS.
  *            If the PHY procedure was rejected by the peer for a different reason, the status will contain the reason as specified by the peer.
  *
  *
  */
 SVCALL(SD_BLE_GAP_PHY_UPDATE, uint32_t, sd_ble_gap_phy_update(uint16_t conn_handle, ble_gap_phys_t const *p_gap_phys));

+#define BLE_HCI_PARAMETER_OUT_OF_MANDATORY_RANGE       0x30            /**< Parameter Out Of Mandatory Range. */
 

 
 
